# 1월 18일 TIL 🔥

# C언어 자료형

## char(character)



- 작은 데이터를 선언하기 좋은 변수 키워드.
- 1바이트의 저장 공간이 있음.
- 문자타입 → %c

### signed char

- 부호가 있는 1바이트 저장 공간.
- -128 ~ 127사이에 저장할 수 있는 종류의 변수를 사용.
    - ex) 온도측정

### unsigned char

- *부호가 없는* 1바이트 공간.
- 0 ~ 255사이의 종류 변수 사용.
    - ex) 나이

## int



- 조금 더 큰 정수를 다루기 위해 사용됨.
- 문자타입 → %d

## short int



- 2바이트의 저장 공간.

### signed short int

- 부호가 있는 2바이트 저장 공간. (-32,768 ~ 32,767)

### unsigned short int

- *부호가 없는* 2바이트 저장 공간. (0 ~ 65,535)

## long int



- 4바이트의 저장 공간.

### signed long int

- 부호가 있는 4바이트 저장 공간. (-2,147,483,648 ~ 2,147,483,647)

### unsigned long int

- *부호가 없는* 4바이트 저장 공간. (0 ~ 4,294,967,295)

## 실수



- 부동소수점 사용
    - 소수점의 위치를 고정하지 않고 소수점의 위치를 나타내는 수를 따로 작성하는 방식.
- 4바이트와 8바이트를 제공.
- 4byte → float (1.2E-38 ~ 3.4E38)
- 8byte → double (2.2E-308 ~ 1.8E308)
- 문자타입 → %f

## 선언문을 사용하는 이유



- 책을 택배로 보내는데 책상만한 박스에 포장하면 공간이 낭비 되듯이 변수도 1바이트의 양을 4바이트에 저장한다면 남은 메모리공간이 낭비되기 때문에 알맞는 데이터 양을 할당할 필요가 있음.

## 1바이트를 왜 char라고 만들었을까?



- 아스키코드를 보면 모든 문자는 1바이트 안에서 해결되어서 1바이트만 사용하면 되는데 적지 않은 프로그래머들이 메모리용량을 계속 마음대로 지정해서 선입견을 주기 위해 char라는 변수명을 만듦.
- char라고 선언한 이후로 문제점이 개선되었지만 한 가지 오해가 생김.
- 많은 개발자들이 char는 문자만 지정해야 한다고 생각함.
- char 키워드는 그냥 1바이트 안에 모든 숫자나 문자를 저장할 수 있음!