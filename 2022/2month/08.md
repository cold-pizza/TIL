# 02/08 TIL 🔥

# 08日 - 이터러블 & 이터레이터

## 이터러블


- 이터러블 프로토콜을 준수한 객체.
- 이터러블 프로토콜(iterable protocol)
    - Symbol.iterator메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환해주는 규약.

### 특징

- for...of 문으로 순회가능.
- 스프레드 문법과 디스트럭처링 할당의 대상으로 사용 가능.

 자주 볼 수 있는 배열, Set, Map도 이터러블에 해당합니다. 한 마디로 딥카피 가능하고 순회가능한 객체를 이터러블이라고 합니다.

## 이터레이터


- `next` 메서드를 소유한 객체.
- 이터레이터 프로토콜을 준수한 객체.
- 이터레이터 프로토콜(iterator protocol)
    - next메서드를 호출하면 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환하자고 약속한 규칙.

### 특징

- next메서드를 사용하여 이터러블을 순회.

 이터레이터는 이터러블을 next()로 순회하는 특징이 있습니다. 이 말은 next()를 호출하지 않으면 **호출한 시점까지만 순회**하여 더 이상 데이터를 생상하지 않는다는 뜻입니다.

## 일반 객체


- 일반 객체는 Symbol.iterator메서드가 없기 때문에 for ...of문으로 순회가 불가능.
- 만약 일반 객체로도 순회하고 싶다면 **유사 배열 객체**로 만들어서 for문으로 순회하는 방법과 Array.from()메서드를 사용해서 객체를 배열로 변환해서 사용하는 방법이 있음.

```jsx
// 유사 배열 객체
const arrayLike = {
	0: 1,
	1: 2,
	2: 3,
	length: 3
}
for (let i = 0; i < arrayLike.length; i++) {
	console.log(arrayLike[i]);
}
// 1 2 3
```

## 이터레이션 프로토콜

ES6이전에는 순회가능한 데이터 컬렉션들이 규약없이 **각자 맞는 반복문**을 구조를 가지고 사용했었습니다. ES6부터 데이터 공급 규약인 이터레이션 프로토콜을 지원하도록 구현되었습니다. 그 이유는 각자의 순회 방식을 가지면 다양한 데이터 공급자의 순회 방식을 모두 지원해야 하기 때문에 **효율성에 적합하지 않아** 하나로 통일 하게 되었습니다. 이처럼 이터레이션 프로토콜은 데이터 공급자(배열, set, map, string...)와 데이터 소비자(for...of, spread, distructuring...)를 이어주는 **인터페이스같은 역할**을 합니다.